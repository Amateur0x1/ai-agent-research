# è¿™äº›å·¥å…·æ˜¯å¦æœ‰å¯èƒ½å®ç°å›é€€åˆ°ä¸Šä¸€æ­¥ï¼Ÿ

## é—®é¢˜åˆ†æ

åœ¨å¤šæ™ºèƒ½ä½“ç³»ç»Ÿä¸­ï¼Œ**å›é€€åŠŸèƒ½**æ˜¯ä¸€ä¸ªå…³é”®éœ€æ±‚ï¼Œå®ƒå…è®¸ç³»ç»Ÿåœ¨å‡ºç°é”™è¯¯ã€ç”¨æˆ·ä¸æ»¡æ„æˆ–éœ€è¦é‡æ–°é€‰æ‹©è·¯å¾„æ—¶ï¼Œèƒ½å¤Ÿè¿”å›åˆ°ä¹‹å‰çš„æŸä¸ªçŠ¶æ€ç»§ç»­æ‰§è¡Œã€‚

## å„æ¡†æ¶å›é€€èƒ½åŠ›å¯¹æ¯”

| æ¡†æ¶ | å›é€€æ”¯æŒ | å®ç°æœºåˆ¶ | å›é€€ç²’åº¦ | å¤æ‚åº¦ |
|------|----------|----------|----------|--------|
| **LangGraph** | âœ… å¼ºæ”¯æŒ | æ£€æŸ¥ç‚¹æœºåˆ¶ | ä»»æ„èŠ‚ç‚¹/çŠ¶æ€ | ä½ |
| **ADK** | âœ… éƒ¨åˆ†æ”¯æŒ | ä¼šè¯ç®¡ç† | æ™ºèƒ½ä½“çº§åˆ« | ä¸­ |
| **Vercel AI SDK** | âš ï¸ æœ‰é™æ”¯æŒ | çŠ¶æ€é‡ç½® | å·¥å…·è°ƒç”¨çº§åˆ« | ä¸­ |
| **AG-UI** | âœ… æ”¯æŒ | çŠ¶æ€å¿«ç…§ | ç»„ä»¶çŠ¶æ€çº§åˆ« | ä½ |

## è¯¦ç»†åˆ†æ

### 1. LangGraph - æœ€å¼ºå›é€€èƒ½åŠ›

LangGraphé€šè¿‡**æ£€æŸ¥ç‚¹æœºåˆ¶**æä¾›äº†æœ€å®Œå–„çš„å›é€€åŠŸèƒ½ï¼š

#### æ—¶é—´æ—…è¡Œèƒ½åŠ›
```python
# æ£€æŸ¥ç‚¹å†å²æŸ¥çœ‹
checkpointer = SqliteSaver("conversation.db")
graph = builder.compile(checkpointer=checkpointer)

# è·å–çŠ¶æ€å†å²
config = {"configurable": {"thread_id": "user_123"}}
state_history = graph.get_state_history(config)

# å›é€€åˆ°ä»»æ„æ£€æŸ¥ç‚¹
for state in state_history:
    print(f"æ­¥éª¤: {state.step}, èŠ‚ç‚¹: {state.metadata['node']}")
    if state.step == 5:  # å›é€€åˆ°ç¬¬5æ­¥
        # ä»è¯¥çŠ¶æ€ç»§ç»­æ‰§è¡Œ
        result = graph.invoke(new_input, config, start_from=state)
```

#### åˆ†æ”¯å’Œé‡æ”¾
```python
# åˆ›å»ºåˆ†æ”¯ - ä»æŸä¸ªæ£€æŸ¥ç‚¹å¼€å§‹æ–°çš„æ‰§è¡Œè·¯å¾„
def create_branch_and_replay(original_thread_id: str, checkpoint_step: int):
    # 1. åˆ›å»ºæ–°çš„åˆ†æ”¯çº¿ç¨‹
    branch_config = {
        "configurable": {
            "thread_id": f"{original_thread_id}_branch_{checkpoint_step}"
        }
    }

    # 2. å¤åˆ¶åˆ°æŒ‡å®šæ£€æŸ¥ç‚¹çš„çŠ¶æ€
    original_state = graph.get_state_at_step(
        {"configurable": {"thread_id": original_thread_id}},
        step=checkpoint_step
    )

    # 3. ä»è¯¥çŠ¶æ€é‡æ–°å¼€å§‹
    return graph.invoke(new_input, branch_config, start_from=original_state)

# ä½¿ç”¨ç¤ºä¾‹
branch_result = create_branch_and_replay("user_123", 5)
```

#### æ™ºèƒ½å›é€€å†³ç­–
```python
class SmartRollbackAgent:
    def __init__(self, graph, checkpointer):
        self.graph = graph
        self.checkpointer = checkpointer

    async def intelligent_rollback(self, config, error_context):
        """åŸºäºé”™è¯¯ç±»å‹æ™ºèƒ½é€‰æ‹©å›é€€ç‚¹"""
        history = self.graph.get_state_history(config)

        for state in reversed(history):
            # åˆ†æè¯¥çŠ¶æ€ç‚¹æ˜¯å¦é€‚åˆå›é€€
            if self.is_safe_rollback_point(state, error_context):
                print(f"æ™ºèƒ½å›é€€åˆ°: {state.metadata['node']}")
                return await self.graph.ainvoke(
                    self.create_recovery_input(error_context),
                    config,
                    start_from=state
                )

    def is_safe_rollback_point(self, state, error_context):
        """åˆ¤æ–­æ˜¯å¦ä¸ºå®‰å…¨çš„å›é€€ç‚¹"""
        # é¿å…å›é€€åˆ°é”™è¯¯çš„æºå¤´
        if error_context.error_type == "tool_execution_error":
            return state.metadata.get('node') != error_context.failed_tool
        return True
```

### 2. ADK - ä¼šè¯çº§å›é€€

ADKé€šè¿‡ä¼šè¯ç®¡ç†æœºåˆ¶æ”¯æŒæ™ºèƒ½ä½“çº§åˆ«çš„å›é€€ï¼š

#### ä¼šè¯çŠ¶æ€å›é€€
```python
class SessionRollbackManager:
    def __init__(self, session_store):
        self.session_store = session_store
        self.state_snapshots = {}

    async def save_snapshot(self, session_id: str, agent_name: str):
        """ä¿å­˜æ™ºèƒ½ä½“çŠ¶æ€å¿«ç…§"""
        session = await self.session_store.get_session(session_id)
        snapshot = {
            'timestamp': datetime.now(),
            'agent': agent_name,
            'messages': session.get_items(),
            'context': session.get_context()
        }

        self.state_snapshots[f"{session_id}_{agent_name}"] = snapshot

    async def rollback_to_agent(self, session_id: str, target_agent: str):
        """å›é€€åˆ°æŒ‡å®šæ™ºèƒ½ä½“"""
        snapshot_key = f"{session_id}_{target_agent}"
        if snapshot_key in self.state_snapshots:
            snapshot = self.state_snapshots[snapshot_key]

            # æ¢å¤ä¼šè¯çŠ¶æ€
            session = await self.session_store.get_session(session_id)
            await session.clear()
            await session.add_items(snapshot['messages'])
            await session.set_context(snapshot['context'])

            return True
        return False

# æ™ºèƒ½ä½“æµç¨‹ä¸­çš„å›é€€ç‚¹è®¾ç½®
class RollbackAwareAgent(LlmAgent):
    def __init__(self, rollback_manager, **kwargs):
        super().__init__(**kwargs)
        self.rollback_manager = rollback_manager

    async def execute(self, session_id: str, input_data):
        # æ‰§è¡Œå‰ä¿å­˜å¿«ç…§
        await self.rollback_manager.save_snapshot(session_id, self.name)

        try:
            result = await super().execute(session_id, input_data)
            return result
        except Exception as e:
            # é”™è¯¯æ—¶æä¾›å›é€€é€‰é¡¹
            return await self.handle_error_with_rollback(session_id, e)
```

#### æ™ºèƒ½ä½“é“¾å›é€€
```python
class SequentialAgentWithRollback(SequentialAgent):
    async def execute_with_rollback_support(self, session_id: str, input_data):
        execution_stack = []

        for i, agent_config in enumerate(self.sub_agents):
            agent = self.load_agent(agent_config)

            # è®°å½•æ‰§è¡Œæ ˆ
            execution_stack.append({
                'agent': agent.name,
                'step': i,
                'input': input_data
            })

            try:
                result = await agent.execute(session_id, input_data)
                input_data = result  # ä¼ é€’ç»™ä¸‹ä¸€ä¸ªæ™ºèƒ½ä½“

            except AgentExecutionError as e:
                # æä¾›å›é€€é€‰é¡¹
                rollback_options = self.generate_rollback_options(execution_stack, e)
                return RollbackPrompt(
                    error=e,
                    options=rollback_options,
                    execution_stack=execution_stack
                )

        return input_data
```

### 3. Vercel AI SDK - å·¥å…·çº§å›é€€

Vercel AI SDKä¸»è¦é€šè¿‡é‡æ–°æ‰§è¡Œå’ŒçŠ¶æ€é‡ç½®å®ç°å›é€€ï¼š

#### å·¥å…·è°ƒç”¨å›é€€
```typescript
class ToolExecutionWithRollback {
  private executionHistory: ToolExecution[] = [];

  async executeWithRollback(tools: Record<string, Tool>, prompt: string) {
    let currentStep = 0;

    while (currentStep < this.maxSteps) {
      const result = await streamText({
        model: openai('gpt-4'),
        tools,
        prompt,

        // è®°å½•æ¯æ¬¡å·¥å…·è°ƒç”¨
        onChunk: ({ chunk }) => {
          if (chunk.type === 'tool-call-start') {
            this.executionHistory.push({
              step: currentStep,
              toolName: chunk.toolName,
              input: chunk.input,
              timestamp: new Date()
            });
          }
        },

        // é”™è¯¯å¤„ç†ä¸å›é€€
        onError: async ({ error }) => {
          const rollbackPoint = await this.findRollbackPoint(error);
          if (rollbackPoint) {
            return this.rollbackAndRetry(rollbackPoint);
          }
          throw error;
        }
      });

      return result;
    }
  }

  private async findRollbackPoint(error: Error): Promise<ToolExecution | null> {
    // åˆ†æé”™è¯¯ï¼Œæ‰¾åˆ°åˆé€‚çš„å›é€€ç‚¹
    for (let i = this.executionHistory.length - 1; i >= 0; i--) {
      const execution = this.executionHistory[i];

      if (this.isSafeRollbackPoint(execution, error)) {
        return execution;
      }
    }
    return null;
  }

  private async rollbackAndRetry(rollbackPoint: ToolExecution) {
    // æ¸…é™¤å›é€€ç‚¹ä¹‹åçš„å†å²
    this.executionHistory = this.executionHistory.filter(
      exec => exec.step <= rollbackPoint.step
    );

    // é‡æ–°æ„é€ ä¸Šä¸‹æ–‡å¹¶ç»§ç»­æ‰§è¡Œ
    const reconstructedContext = this.reconstructContext(rollbackPoint);
    return this.executeFromPoint(rollbackPoint, reconstructedContext);
  }
}
```

#### æ­¥éª¤çº§é‡è¯•æœºåˆ¶
```typescript
// é€šè¿‡stopWhenå’Œé‡è¯•å®ç°å›é€€æ•ˆæœ
const retryableExecution = async (prompt: string, maxRetries: number = 3) => {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const result = await streamText({
        model: openai('gpt-4'),
        tools: { researcher, analyzer, writer },
        prompt,

        stopWhen: (result) => {
          // æ£€æŸ¥ç»“æœè´¨é‡
          const quality = evaluateQuality(result.text);
          if (quality < 0.7 && attempt < maxRetries - 1) {
            // è´¨é‡ä¸å¤Ÿä¸”è¿˜æœ‰é‡è¯•æœºä¼šï¼Œè§¦å‘å›é€€
            throw new QualityError(`è´¨é‡ä¸è¾¾æ ‡: ${quality}`);
          }
          return result.toolCalls.length >= 3; // æ­£å¸¸åœæ­¢æ¡ä»¶
        }
      });

      return result;

    } catch (error) {
      if (error instanceof QualityError && attempt < maxRetries - 1) {
        console.log(`ç¬¬${attempt + 1}æ¬¡å°è¯•è´¨é‡ä¸è¾¾æ ‡ï¼Œå›é€€é‡è¯•...`);
        // è¿™é‡Œå¯ä»¥è°ƒæ•´promptæˆ–å·¥å…·ç­–ç•¥
        prompt = adjustPromptForRetry(prompt, error);
        continue;
      }
      throw error;
    }
  }
};
```

### 4. AG-UI - UIçŠ¶æ€å›é€€

AG-UIé€šè¿‡çŠ¶æ€å¿«ç…§æœºåˆ¶æ”¯æŒç•Œé¢çº§å›é€€ï¼š

#### çŠ¶æ€å¿«ç…§ç®¡ç†
```typescript
interface StateSnapshot {
  id: string;
  timestamp: number;
  agentState: TravelAgentState;
  uiState: UIState;
  userActions: UserAction[];
}

class AGUIRollbackManager {
  private snapshots: StateSnapshot[] = [];
  private maxSnapshots = 10;

  saveSnapshot(agentState: TravelAgentState, uiState: UIState) {
    const snapshot: StateSnapshot = {
      id: `snapshot_${Date.now()}`,
      timestamp: Date.now(),
      agentState: deepClone(agentState),
      uiState: deepClone(uiState),
      userActions: [...this.getCurrentUserActions()]
    };

    this.snapshots.push(snapshot);

    // ä¿æŒå¿«ç…§æ•°é‡é™åˆ¶
    if (this.snapshots.length > this.maxSnapshots) {
      this.snapshots.shift();
    }
  }

  rollbackToSnapshot(snapshotId: string): StateSnapshot | null {
    const snapshot = this.snapshots.find(s => s.id === snapshotId);
    if (!snapshot) return null;

    // æ¸…é™¤è¯¥å¿«ç…§ä¹‹åçš„æ‰€æœ‰å¿«ç…§
    const snapshotIndex = this.snapshots.findIndex(s => s.id === snapshotId);
    this.snapshots = this.snapshots.slice(0, snapshotIndex + 1);

    return snapshot;
  }

  getAvailableRollbackPoints(): StateSnapshot[] {
    return this.snapshots.map(snapshot => ({
      ...snapshot,
      // åªè¿”å›å¿…è¦çš„å…ƒæ•°æ®ï¼Œä¸åŒ…å«å®Œæ•´çŠ¶æ€
      agentState: undefined,
      uiState: undefined
    }));
  }
}

// Reactç»„ä»¶ä¸­çš„ä½¿ç”¨
function TravelPlannerWithRollback() {
  const [snapshots, setSnapshots] = useState<StateSnapshot[]>([]);
  const [showRollbackDialog, setShowRollbackDialog] = useState(false);
  const rollbackManager = useRef(new AGUIRollbackManager());

  const { state: agentState, nodeName } = useCoAgent<TravelAgentState>({
    name: "subgraphs",
    initialState: INITIAL_STATE,

    // åœ¨å…³é”®æ­¥éª¤ä¿å­˜å¿«ç…§
    onStateChange: (newState) => {
      if (isKeyMilestone(newState)) {
        rollbackManager.current.saveSnapshot(newState, getCurrentUIState());
        setSnapshots(rollbackManager.current.getAvailableRollbackPoints());
      }
    }
  });

  const handleRollback = (snapshotId: string) => {
    const snapshot = rollbackManager.current.rollbackToSnapshot(snapshotId);
    if (snapshot) {
      // æ¢å¤çŠ¶æ€
      restoreAgentState(snapshot.agentState);
      restoreUIState(snapshot.uiState);
      setShowRollbackDialog(false);
    }
  };

  return (
    <div>
      {/* ä¸»ç•Œé¢ */}
      <TravelPlannerInterface agentState={agentState} />

      {/* å›é€€æ§åˆ¶ */}
      <div className="rollback-controls">
        <button onClick={() => setShowRollbackDialog(true)}>
          ğŸ”„ å›é€€åˆ°ä¹‹å‰çš„æ­¥éª¤
        </button>
      </div>

      {/* å›é€€å¯¹è¯æ¡† */}
      {showRollbackDialog && (
        <RollbackDialog
          snapshots={snapshots}
          onRollback={handleRollback}
          onCancel={() => setShowRollbackDialog(false)}
        />
      )}
    </div>
  );
}
```

## å›é€€åŠŸèƒ½å®ç°çš„æœ€ä½³å®è·µ

### 1. è®¾è®¡åŸåˆ™
- **ç²’åº¦åˆé€‚**: æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©åˆé€‚çš„å›é€€ç²’åº¦
- **æ€§èƒ½è€ƒè™‘**: é¿å…è¿‡åº¦ä¿å­˜çŠ¶æ€é€ æˆæ€§èƒ½é—®é¢˜
- **ç”¨æˆ·ä½“éªŒ**: æä¾›æ¸…æ™°çš„å›é€€é€‰é¡¹å’Œé¢„è§ˆåŠŸèƒ½

### 2. æŠ€æœ¯å®ç°
- **çŠ¶æ€ç®¡ç†**: ä½¿ç”¨ä¸å¯å˜æ•°æ®ç»“æ„ä¾¿äºçŠ¶æ€å›æ»š
- **å­˜å‚¨ä¼˜åŒ–**: é‡‡ç”¨å¢é‡å­˜å‚¨å‡å°‘ç©ºé—´å ç”¨
- **ä¸€è‡´æ€§ä¿è¯**: ç¡®ä¿å›é€€åçš„çŠ¶æ€ä¸€è‡´æ€§

### 3. ä¸šåŠ¡åœºæ™¯
- **é”™è¯¯æ¢å¤**: è‡ªåŠ¨å›é€€åˆ°æœ€è¿‘çš„å®‰å…¨ç‚¹
- **ç”¨æˆ·åæ‚”**: å…è®¸ç”¨æˆ·æ’¤é”€ä¸æ»¡æ„çš„æ“ä½œ
- **åˆ†æ”¯æ¢ç´¢**: æ”¯æŒä»åŒä¸€ç‚¹å°è¯•ä¸åŒçš„æ‰§è¡Œè·¯å¾„

## æ€»ç»“

å„æ¡†æ¶çš„å›é€€èƒ½åŠ›æ’åºï¼š
1. **LangGraph** - æä¾›æœ€å®Œå–„çš„æ—¶é—´æ—…è¡Œå’ŒçŠ¶æ€å›é€€èƒ½åŠ›
2. **AG-UI** - åœ¨UIå±‚é¢æä¾›è‰¯å¥½çš„å›é€€ä½“éªŒ
3. **ADK** - æ”¯æŒæ™ºèƒ½ä½“çº§åˆ«çš„ä¼šè¯å›é€€
4. **Vercel AI SDK** - é€šè¿‡é‡è¯•æœºåˆ¶å®ç°æœ‰é™çš„å›é€€åŠŸèƒ½

**å»ºè®®**ï¼š
- å¯¹äºå¤æ‚çš„å¤šæ­¥éª¤æ¨ç†ä»»åŠ¡ï¼Œé€‰æ‹©LangGraph
- å¯¹äºç”¨æˆ·äº¤äº’ä¸ºä¸»çš„åº”ç”¨ï¼ŒAG-UIæä¾›äº†å¾ˆå¥½çš„å›é€€ä½“éªŒ
- å¯¹äºä¼ä¸šçº§åº”ç”¨ï¼ŒADKçš„ä¼šè¯ç®¡ç†æœºåˆ¶è¶³å¤Ÿå®ç”¨
- å¯¹äºå‰ç«¯åº”ç”¨ï¼ŒVercel AI SDKå¯ä»¥é€šè¿‡è‡ªå®šä¹‰é€»è¾‘å®ç°å›é€€åŠŸèƒ½
