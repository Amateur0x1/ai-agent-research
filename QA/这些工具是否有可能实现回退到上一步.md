# 这些工具是否有可能实现回退到上一步？

## 问题分析

在多智能体系统中，**回退功能**是一个关键需求，它允许系统在出现错误、用户不满意或需要重新选择路径时，能够返回到之前的某个状态继续执行。

## 各框架回退能力对比

| 框架 | 回退支持 | 实现机制 | 回退粒度 | 复杂度 |
|------|----------|----------|----------|--------|
| **LangGraph** | ✅ 强支持 | 检查点机制 | 任意节点/状态 | 低 |
| **ADK** | ✅ 部分支持 | 会话管理 | 智能体级别 | 中 |
| **Vercel AI SDK** | ⚠️ 有限支持 | 状态重置 | 工具调用级别 | 中 |
| **AG-UI** | ✅ 支持 | 状态快照 | 组件状态级别 | 低 |

## 详细分析

### 1. LangGraph - 最强回退能力

LangGraph通过**检查点机制**提供了最完善的回退功能：

#### 时间旅行能力
```python
# 检查点历史查看
checkpointer = SqliteSaver("conversation.db")
graph = builder.compile(checkpointer=checkpointer)

# 获取状态历史
config = {"configurable": {"thread_id": "user_123"}}
state_history = graph.get_state_history(config)

# 回退到任意检查点
for state in state_history:
    print(f"步骤: {state.step}, 节点: {state.metadata['node']}")
    if state.step == 5:  # 回退到第5步
        # 从该状态继续执行
        result = graph.invoke(new_input, config, start_from=state)
```

#### 分支和重放
```python
# 创建分支 - 从某个检查点开始新的执行路径
def create_branch_and_replay(original_thread_id: str, checkpoint_step: int):
    # 1. 创建新的分支线程
    branch_config = {
        "configurable": {
            "thread_id": f"{original_thread_id}_branch_{checkpoint_step}"
        }
    }

    # 2. 复制到指定检查点的状态
    original_state = graph.get_state_at_step(
        {"configurable": {"thread_id": original_thread_id}},
        step=checkpoint_step
    )

    # 3. 从该状态重新开始
    return graph.invoke(new_input, branch_config, start_from=original_state)

# 使用示例
branch_result = create_branch_and_replay("user_123", 5)
```

#### 智能回退决策
```python
class SmartRollbackAgent:
    def __init__(self, graph, checkpointer):
        self.graph = graph
        self.checkpointer = checkpointer

    async def intelligent_rollback(self, config, error_context):
        """基于错误类型智能选择回退点"""
        history = self.graph.get_state_history(config)

        for state in reversed(history):
            # 分析该状态点是否适合回退
            if self.is_safe_rollback_point(state, error_context):
                print(f"智能回退到: {state.metadata['node']}")
                return await self.graph.ainvoke(
                    self.create_recovery_input(error_context),
                    config,
                    start_from=state
                )

    def is_safe_rollback_point(self, state, error_context):
        """判断是否为安全的回退点"""
        # 避免回退到错误的源头
        if error_context.error_type == "tool_execution_error":
            return state.metadata.get('node') != error_context.failed_tool
        return True
```

### 2. ADK - 会话级回退

ADK通过会话管理机制支持智能体级别的回退：

#### 会话状态回退
```python
class SessionRollbackManager:
    def __init__(self, session_store):
        self.session_store = session_store
        self.state_snapshots = {}

    async def save_snapshot(self, session_id: str, agent_name: str):
        """保存智能体状态快照"""
        session = await self.session_store.get_session(session_id)
        snapshot = {
            'timestamp': datetime.now(),
            'agent': agent_name,
            'messages': session.get_items(),
            'context': session.get_context()
        }

        self.state_snapshots[f"{session_id}_{agent_name}"] = snapshot

    async def rollback_to_agent(self, session_id: str, target_agent: str):
        """回退到指定智能体"""
        snapshot_key = f"{session_id}_{target_agent}"
        if snapshot_key in self.state_snapshots:
            snapshot = self.state_snapshots[snapshot_key]

            # 恢复会话状态
            session = await self.session_store.get_session(session_id)
            await session.clear()
            await session.add_items(snapshot['messages'])
            await session.set_context(snapshot['context'])

            return True
        return False

# 智能体流程中的回退点设置
class RollbackAwareAgent(LlmAgent):
    def __init__(self, rollback_manager, **kwargs):
        super().__init__(**kwargs)
        self.rollback_manager = rollback_manager

    async def execute(self, session_id: str, input_data):
        # 执行前保存快照
        await self.rollback_manager.save_snapshot(session_id, self.name)

        try:
            result = await super().execute(session_id, input_data)
            return result
        except Exception as e:
            # 错误时提供回退选项
            return await self.handle_error_with_rollback(session_id, e)
```

#### 智能体链回退
```python
class SequentialAgentWithRollback(SequentialAgent):
    async def execute_with_rollback_support(self, session_id: str, input_data):
        execution_stack = []

        for i, agent_config in enumerate(self.sub_agents):
            agent = self.load_agent(agent_config)

            # 记录执行栈
            execution_stack.append({
                'agent': agent.name,
                'step': i,
                'input': input_data
            })

            try:
                result = await agent.execute(session_id, input_data)
                input_data = result  # 传递给下一个智能体

            except AgentExecutionError as e:
                # 提供回退选项
                rollback_options = self.generate_rollback_options(execution_stack, e)
                return RollbackPrompt(
                    error=e,
                    options=rollback_options,
                    execution_stack=execution_stack
                )

        return input_data
```

### 3. Vercel AI SDK - 工具级回退

Vercel AI SDK主要通过重新执行和状态重置实现回退：

#### 工具调用回退
```typescript
class ToolExecutionWithRollback {
  private executionHistory: ToolExecution[] = [];

  async executeWithRollback(tools: Record<string, Tool>, prompt: string) {
    let currentStep = 0;

    while (currentStep < this.maxSteps) {
      const result = await streamText({
        model: openai('gpt-4'),
        tools,
        prompt,

        // 记录每次工具调用
        onChunk: ({ chunk }) => {
          if (chunk.type === 'tool-call-start') {
            this.executionHistory.push({
              step: currentStep,
              toolName: chunk.toolName,
              input: chunk.input,
              timestamp: new Date()
            });
          }
        },

        // 错误处理与回退
        onError: async ({ error }) => {
          const rollbackPoint = await this.findRollbackPoint(error);
          if (rollbackPoint) {
            return this.rollbackAndRetry(rollbackPoint);
          }
          throw error;
        }
      });

      return result;
    }
  }

  private async findRollbackPoint(error: Error): Promise<ToolExecution | null> {
    // 分析错误，找到合适的回退点
    for (let i = this.executionHistory.length - 1; i >= 0; i--) {
      const execution = this.executionHistory[i];

      if (this.isSafeRollbackPoint(execution, error)) {
        return execution;
      }
    }
    return null;
  }

  private async rollbackAndRetry(rollbackPoint: ToolExecution) {
    // 清除回退点之后的历史
    this.executionHistory = this.executionHistory.filter(
      exec => exec.step <= rollbackPoint.step
    );

    // 重新构造上下文并继续执行
    const reconstructedContext = this.reconstructContext(rollbackPoint);
    return this.executeFromPoint(rollbackPoint, reconstructedContext);
  }
}
```

#### 步骤级重试机制
```typescript
// 通过stopWhen和重试实现回退效果
const retryableExecution = async (prompt: string, maxRetries: number = 3) => {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const result = await streamText({
        model: openai('gpt-4'),
        tools: { researcher, analyzer, writer },
        prompt,

        stopWhen: (result) => {
          // 检查结果质量
          const quality = evaluateQuality(result.text);
          if (quality < 0.7 && attempt < maxRetries - 1) {
            // 质量不够且还有重试机会，触发回退
            throw new QualityError(`质量不达标: ${quality}`);
          }
          return result.toolCalls.length >= 3; // 正常停止条件
        }
      });

      return result;

    } catch (error) {
      if (error instanceof QualityError && attempt < maxRetries - 1) {
        console.log(`第${attempt + 1}次尝试质量不达标，回退重试...`);
        // 这里可以调整prompt或工具策略
        prompt = adjustPromptForRetry(prompt, error);
        continue;
      }
      throw error;
    }
  }
};
```

### 4. AG-UI - UI状态回退

AG-UI通过状态快照机制支持界面级回退：

#### 状态快照管理
```typescript
interface StateSnapshot {
  id: string;
  timestamp: number;
  agentState: TravelAgentState;
  uiState: UIState;
  userActions: UserAction[];
}

class AGUIRollbackManager {
  private snapshots: StateSnapshot[] = [];
  private maxSnapshots = 10;

  saveSnapshot(agentState: TravelAgentState, uiState: UIState) {
    const snapshot: StateSnapshot = {
      id: `snapshot_${Date.now()}`,
      timestamp: Date.now(),
      agentState: deepClone(agentState),
      uiState: deepClone(uiState),
      userActions: [...this.getCurrentUserActions()]
    };

    this.snapshots.push(snapshot);

    // 保持快照数量限制
    if (this.snapshots.length > this.maxSnapshots) {
      this.snapshots.shift();
    }
  }

  rollbackToSnapshot(snapshotId: string): StateSnapshot | null {
    const snapshot = this.snapshots.find(s => s.id === snapshotId);
    if (!snapshot) return null;

    // 清除该快照之后的所有快照
    const snapshotIndex = this.snapshots.findIndex(s => s.id === snapshotId);
    this.snapshots = this.snapshots.slice(0, snapshotIndex + 1);

    return snapshot;
  }

  getAvailableRollbackPoints(): StateSnapshot[] {
    return this.snapshots.map(snapshot => ({
      ...snapshot,
      // 只返回必要的元数据，不包含完整状态
      agentState: undefined,
      uiState: undefined
    }));
  }
}

// React组件中的使用
function TravelPlannerWithRollback() {
  const [snapshots, setSnapshots] = useState<StateSnapshot[]>([]);
  const [showRollbackDialog, setShowRollbackDialog] = useState(false);
  const rollbackManager = useRef(new AGUIRollbackManager());

  const { state: agentState, nodeName } = useCoAgent<TravelAgentState>({
    name: "subgraphs",
    initialState: INITIAL_STATE,

    // 在关键步骤保存快照
    onStateChange: (newState) => {
      if (isKeyMilestone(newState)) {
        rollbackManager.current.saveSnapshot(newState, getCurrentUIState());
        setSnapshots(rollbackManager.current.getAvailableRollbackPoints());
      }
    }
  });

  const handleRollback = (snapshotId: string) => {
    const snapshot = rollbackManager.current.rollbackToSnapshot(snapshotId);
    if (snapshot) {
      // 恢复状态
      restoreAgentState(snapshot.agentState);
      restoreUIState(snapshot.uiState);
      setShowRollbackDialog(false);
    }
  };

  return (
    <div>
      {/* 主界面 */}
      <TravelPlannerInterface agentState={agentState} />

      {/* 回退控制 */}
      <div className="rollback-controls">
        <button onClick={() => setShowRollbackDialog(true)}>
          🔄 回退到之前的步骤
        </button>
      </div>

      {/* 回退对话框 */}
      {showRollbackDialog && (
        <RollbackDialog
          snapshots={snapshots}
          onRollback={handleRollback}
          onCancel={() => setShowRollbackDialog(false)}
        />
      )}
    </div>
  );
}
```

## 回退功能实现的最佳实践

### 1. 设计原则
- **粒度合适**: 根据业务需求选择合适的回退粒度
- **性能考虑**: 避免过度保存状态造成性能问题
- **用户体验**: 提供清晰的回退选项和预览功能

### 2. 技术实现
- **状态管理**: 使用不可变数据结构便于状态回滚
- **存储优化**: 采用增量存储减少空间占用
- **一致性保证**: 确保回退后的状态一致性

### 3. 业务场景
- **错误恢复**: 自动回退到最近的安全点
- **用户反悔**: 允许用户撤销不满意的操作
- **分支探索**: 支持从同一点尝试不同的执行路径

## 总结

各框架的回退能力排序：
1. **LangGraph** - 提供最完善的时间旅行和状态回退能力
2. **AG-UI** - 在UI层面提供良好的回退体验
3. **ADK** - 支持智能体级别的会话回退
4. **Vercel AI SDK** - 通过重试机制实现有限的回退功能

**建议**：
- 对于复杂的多步骤推理任务，选择LangGraph
- 对于用户交互为主的应用，AG-UI提供了很好的回退体验
- 对于企业级应用，ADK的会话管理机制足够实用
- 对于前端应用，Vercel AI SDK可以通过自定义逻辑实现回退功能
